#!/usr/bin/env python
import os
import glob
import sys
import argparse
import logging as log
from os.path import join,normpath,abspath,islink, split
from pprint import pformat
from itertools import combinations

def call(command,fake = False):
    """ call(command) --> (result, output)
        Runs the command in the local shell returning a tuple 
        containing :
            - the return result (None for 0, otherwise an int), and
            - the full, stripped standard output.  """
    if fake:
        return

    process = os.popen(command)
    output = []
    line = process.readline()

    while not line == "":
        sys.stdout.flush()
        output.append(line)
        line = process.readline()
    result = process.close()

    return (result, "".join(output).strip())

def lowercase_list_and_casemap(files):
    found = []
    casemap = {}
    for f in files:
        if set(f) and set(target).issubset(set(f)):
            found.append(f.lower())
            casemap[f.lower()] = f
    return found, casemap

def reverse(s):
    ls = list(s)
    ls.reverse()
    return ''.join(ls)

def splittable(a):
    if len(a) > 0:
        return [(a,'')] + [(a[:n],a[n:]) for n in reversed(range(len(a)))]
    else:
        return []

def chunk(combination,tosearch,found):
    log.debug('checking combination %s with currentsearch ' % (reverse(combination[0]), revstr(combination[1])))
    for i,r in enumerate(tosearch):
        rres = reverse(r)
        if combination[0] in rres:
            found.add(r)
    if found:
        log.debug('found %s' % len(found))
        log.debug('found %s' % pformat(found))
    return found, combination[1]

def onepass(target, tosearch):
    found = set()
    currentsearch = None
    log.debug('target %s' % reverse(target))
    if len(target) > 3:
        combs = splittable(target)
    else:
        return tosearch, ''

    for i, combination in enumerate(combs):
        if found:
            return found, currentsearch

        if combination[0] != '':
            for j,r in enumerate(tosearch):
                rres = reverse(r)
                if combination[0] in rres:
                    found.add(r)
            if found:
                log.debug('combination %s %s' % (i, reverse(combination[0])))
                log.debug('currentsearch [%s]' % reverse(combination[1]))
                currentsearch = combination[1]

def get_options():
    parser = argparse.ArgumentParser(description='command-t like shell command')
    parser.add_argument('target', metavar='target', help='the target string to search')
    parser.add_argument('-c', '--command', help='command to collect a list of files (default: git ls-files)')
    parser.add_argument('-f', '--use-find', action='store_true', help='use find collect command (find . -type f)')
    parser.add_argument('-m', '--max', type=int, help='stop at max results')
    parser.add_argument('-v', '--verbose', action='store_true', help='verbose: print out debug information')
    return parser.parse_args()

if __name__ == '__main__':
    maxres = 20
    collect_command = 'git ls-files'
    find_collect_command = 'find . -type f'

    options = get_options()

    target = options.target
    if options.verbose:
        log.basicConfig(level=log.DEBUG)
    else:
        log.basicConfig(level=log.INFO)

    if options.command:
        collect_command = options.command 

    if options.max:
        maxres = options.max

    files = call(collect_command)[1].split('\n')

    found, casemap = lowercase_list_and_casemap(files)
    found.sort()

    currentsearch = reverse(target)

    i = 0
    while True:
        i = i + 1
        log.debug('pass n.%s' % i)
        found, currentsearch = onepass(currentsearch, found)
        log.debug('found %s' % len(found))
        log.debug(pformat([casemap[f] for f in list(found)[:30]]))
        if len(currentsearch) < 2:
            break

    log.debug('final results:')
    print '\n'.join([casemap[f] for f in list(found)[:maxres]])
