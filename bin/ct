#!/usr/bin/env python
import os
import glob
import sys
import argparse
import subprocess
import logging as log
from os.path import join,normpath,abspath,islink, split
from pprint import pformat, pprint
from itertools import combinations

class Bunch:
    def __init__(self, **kwds):
        self.__dict__.update(kwds)

def containsAll(str, set):
    for c in set:
        if c not in str: 
            return 0
        else:
            lstr = list(str)
            del(lstr[str.find(c)])
            str = ''.join(lstr)

    return 1;

def call(command):
    return subprocess.Popen(command.split(),stdout=subprocess.PIPE, stderr=open(os.devnull, 'w')).communicate()

def lowercase_list_and_casemap(files, target):
    found = []
    casemap = {}
    for f in files:
        if f and containsAll(f,target):
            found.append(f.lower())
            casemap[f.lower()] = f
    return found, casemap

def reverse(s):
    ls = list(s)
    ls.reverse()
    return ''.join(ls)

def get_options():
    maxres = 10
    debug = ''
    collect_command = 'git ls-files'
    find_collect_command = 'find . -type f'

    parser = argparse.ArgumentParser(description='command-t like shell command')
    parser.add_argument('target', metavar='target', help='the target pattern to search')
    parser.add_argument('-c', '--command', help='command to collect a list of files (default: git ls-files)')
    parser.add_argument('-f', '--find', action='store_true', help='use find collect command (find . -type f)')
    parser.add_argument('-m', '--max', type=int, help='stop at max results')
    parser.add_argument('-d', '--debug', type=str, help='file to debug expansion')
    parser.add_argument('-v', '--verbose', action='store_true', help='verbose: print out debug information')
    options = parser.parse_args()

    if options.verbose:
        log.basicConfig(level=log.DEBUG)
    else:
        log.basicConfig(level=log.INFO)

    if options.find:
        collect_command = find_collect_command
    elif options.command:
        collect_command = options.command 

    if options.max:
        maxres = options.max

    if options.debug:
        debug = options.debug

    return options.target, collect_command, maxres, debug

def positions_of_char(char, s):
    result = []
    pos = 0
    for i in range(s.count(char)):
        pos = s.find(char,pos + 1)
        result.append(pos)
    return result

def build_chars_positions_matrix(target, candidate):
    char_matrix = []
    #min_pos = 0
    for c in target:
        positions = positions_of_char(c, candidate)
        #log.debug('%s %s' % (c, positions))
        #positions = [p for p in positions if p > min_pos]
        if not positions:
            return None
        #min_pos = positions[0]
        #log.debug('updating min_pos to %s' % min_pos)
        char_matrix.append(Bunch(char=c,positions=positions))
    return char_matrix

def min_diff(a,b):
    diffs = []
    for i in a:
        for j in b:
            if j > i:
                diffs.append(j-i)
    if diffs:
        return min(diffs)
    else:
        return 1000

def calculate_min_diff(char_matrix):
    score = 0
    for i, b in enumerate(char_matrix):
        if i < len(char_matrix) - 1:
          log.debug('%s-%s| %s %s = %s' % (b.char,char_matrix[i+1].char, b.positions, char_matrix[i+1].positions, min_diff(b.positions, char_matrix[i+1].positions)))
          score = score + min_diff(b.positions, char_matrix[i+1].positions)
    return score

def calculate_score(target, candidate):
    char_matrix = build_chars_positions_matrix(target,candidate)
    if char_matrix:
        return calculate_min_diff(char_matrix)
    else:
        return 1000

if __name__ == '__main__':

    target, collect_command, maxres, debug = get_options()

    collected, exitcode = call(collect_command)
    if not collected:
        log.error('no results returned by %s' % collect_command)
        sys.exit(1)

    files = collected.split('\n')
    found, casemap = lowercase_list_and_casemap(files, target)
    found.sort()

    if debug:
        log.debug('troubleshooting: %s' % debug.lower())
        score = calculate_score(target, debug.lower())
        log.debug('score: %s' % score)
    else:
        result = []
        for f in found:
            score = calculate_score(target, f)
            if score < 1000:
                result.append((score,casemap[f]))

        log.debug('\n'.join([str(f) for f in sorted(result)[:maxres]]))
        print '\n'.join([f[1] for f in sorted(result)[:maxres]])
